/**
 * @file x64_encode.c
 * @brief MC27: x86-64 Instruction Encoder Implementation
 *
 * Native x86-64 machine code generation for Seraphim.
 * This is the foundation of SERAPH's compiler independence.
 *
 * Philosophy: SERAPH doesn't depend on GCC, Clang, or any external compiler.
 * Every byte of machine code is generated by our own encoder.
 *
 * This encoder implements the x86-64 instruction set with focus on:
 * - VOID-aware instruction sequences
 * - Capability-safe memory access patterns
 * - Substrate-aware load/store operations
 * - SERAPH calling convention support
 */

#include "seraph/seraphim/x64_encode.h"
#include <stdlib.h>
#include <string.h>

/*============================================================================
 * Buffer Management
 *============================================================================*/

Seraph_Vbit x64_buf_init(X64_Buffer* buf, size_t initial_capacity) {
    if (buf == NULL || initial_capacity == 0) {
        return SERAPH_VBIT_FALSE;
    }

    buf->code = (uint8_t*)malloc(initial_capacity);
    if (buf->code == NULL) {
        return SERAPH_VBIT_FALSE;
    }

    buf->size = 0;
    buf->capacity = initial_capacity;
    buf->relocs = NULL;
    buf->reloc_count = 0;
    buf->reloc_capacity = 0;

    return SERAPH_VBIT_TRUE;
}

void x64_buf_free(X64_Buffer* buf) {
    if (buf == NULL) return;

    if (buf->code != NULL) {
        free(buf->code);
        buf->code = NULL;
    }
    if (buf->relocs != NULL) {
        free(buf->relocs);
        buf->relocs = NULL;
    }

    buf->size = 0;
    buf->capacity = 0;
    buf->reloc_count = 0;
    buf->reloc_capacity = 0;
}

Seraph_Vbit x64_buf_reserve(X64_Buffer* buf, size_t n) {
    if (buf == NULL) return SERAPH_VBIT_FALSE;

    if (buf->size + n <= buf->capacity) {
        return SERAPH_VBIT_TRUE;
    }

    /* Grow by at least 2x */
    size_t new_capacity = buf->capacity * 2;
    if (new_capacity < buf->size + n) {
        new_capacity = buf->size + n;
    }

    uint8_t* new_code = (uint8_t*)realloc(buf->code, new_capacity);
    if (new_code == NULL) {
        return SERAPH_VBIT_FALSE;
    }

    buf->code = new_code;
    buf->capacity = new_capacity;
    return SERAPH_VBIT_TRUE;
}

void x64_emit_byte(X64_Buffer* buf, uint8_t b) {
    if (buf == NULL) return;
    if (x64_buf_reserve(buf, 1) != SERAPH_VBIT_TRUE) return;

    buf->code[buf->size++] = b;
}

void x64_emit_word(X64_Buffer* buf, uint16_t w) {
    if (buf == NULL) return;
    if (x64_buf_reserve(buf, 2) != SERAPH_VBIT_TRUE) return;

    /* Little-endian */
    buf->code[buf->size++] = (uint8_t)(w & 0xFF);
    buf->code[buf->size++] = (uint8_t)((w >> 8) & 0xFF);
}

void x64_emit_dword(X64_Buffer* buf, uint32_t d) {
    if (buf == NULL) return;
    if (x64_buf_reserve(buf, 4) != SERAPH_VBIT_TRUE) return;

    /* Little-endian */
    buf->code[buf->size++] = (uint8_t)(d & 0xFF);
    buf->code[buf->size++] = (uint8_t)((d >> 8) & 0xFF);
    buf->code[buf->size++] = (uint8_t)((d >> 16) & 0xFF);
    buf->code[buf->size++] = (uint8_t)((d >> 24) & 0xFF);
}

void x64_emit_qword(X64_Buffer* buf, uint64_t q) {
    if (buf == NULL) return;
    if (x64_buf_reserve(buf, 8) != SERAPH_VBIT_TRUE) return;

    /* Little-endian */
    for (int i = 0; i < 8; i++) {
        buf->code[buf->size++] = (uint8_t)((q >> (i * 8)) & 0xFF);
    }
}

/*============================================================================
 * Label Management
 *============================================================================*/

Seraph_Vbit x64_labels_init(X64_Labels* labels) {
    if (labels == NULL) return SERAPH_VBIT_FALSE;

    labels->labels = NULL;
    labels->count = 0;
    labels->capacity = 0;

    labels->fixups = NULL;
    labels->fixup_count = 0;
    labels->fixup_capacity = 0;

    labels->next_id = 1;  /* Start at 1, 0 is invalid */

    return SERAPH_VBIT_TRUE;
}

void x64_labels_free(X64_Labels* labels) {
    if (labels == NULL) return;

    if (labels->labels != NULL) {
        free(labels->labels);
        labels->labels = NULL;
    }
    if (labels->fixups != NULL) {
        free(labels->fixups);
        labels->fixups = NULL;
    }

    labels->count = 0;
    labels->capacity = 0;
    labels->fixup_count = 0;
    labels->fixup_capacity = 0;
}

uint32_t x64_label_create(X64_Labels* labels) {
    if (labels == NULL) return UINT32_MAX;

    /* Grow array if needed */
    if (labels->count >= labels->capacity) {
        size_t new_capacity = labels->capacity == 0 ? 16 : labels->capacity * 2;
        X64_Label* new_labels = (X64_Label*)realloc(labels->labels,
                                                      new_capacity * sizeof(X64_Label));
        if (new_labels == NULL) return UINT32_MAX;
        labels->labels = new_labels;
        labels->capacity = new_capacity;
    }

    uint32_t id = labels->next_id++;
    labels->labels[labels->count].id = id;
    labels->labels[labels->count].offset = SIZE_MAX;  /* Undefined */
    labels->count++;

    return id;
}

Seraph_Vbit x64_label_define(X64_Labels* labels, X64_Buffer* buf, uint32_t label_id) {
    if (labels == NULL || buf == NULL || label_id == 0) {
        return SERAPH_VBIT_FALSE;
    }

    /* Find the label */
    for (size_t i = 0; i < labels->count; i++) {
        if (labels->labels[i].id == label_id) {
            if (labels->labels[i].offset != SIZE_MAX) {
                /* Already defined - error */
                return SERAPH_VBIT_FALSE;
            }
            labels->labels[i].offset = buf->size;
            return SERAPH_VBIT_TRUE;
        }
    }

    /* Label not found - create it */
    if (labels->count >= labels->capacity) {
        size_t new_capacity = labels->capacity == 0 ? 16 : labels->capacity * 2;
        X64_Label* new_labels = (X64_Label*)realloc(labels->labels,
                                                      new_capacity * sizeof(X64_Label));
        if (new_labels == NULL) return SERAPH_VBIT_FALSE;
        labels->labels = new_labels;
        labels->capacity = new_capacity;
    }

    labels->labels[labels->count].id = label_id;
    labels->labels[labels->count].offset = buf->size;
    labels->count++;

    /* Update next_id if needed */
    if (label_id >= labels->next_id) {
        labels->next_id = label_id + 1;
    }

    return SERAPH_VBIT_TRUE;
}

Seraph_Vbit x64_label_fixup(X64_Labels* labels, X64_Buffer* buf,
                            uint32_t label_id, int8_t size) {
    if (labels == NULL || buf == NULL || label_id == 0) {
        return SERAPH_VBIT_FALSE;
    }

    /* Grow fixup array if needed */
    if (labels->fixup_count >= labels->fixup_capacity) {
        size_t new_capacity = labels->fixup_capacity == 0 ? 32 : labels->fixup_capacity * 2;
        X64_Fixup* new_fixups = (X64_Fixup*)realloc(labels->fixups,
                                                      new_capacity * sizeof(X64_Fixup));
        if (new_fixups == NULL) return SERAPH_VBIT_FALSE;
        labels->fixups = new_fixups;
        labels->fixup_capacity = new_capacity;
    }

    labels->fixups[labels->fixup_count].patch_offset = buf->size;
    labels->fixups[labels->fixup_count].label_id = label_id;
    labels->fixups[labels->fixup_count].size = size;
    labels->fixup_count++;

    /* Emit placeholder bytes */
    for (int8_t i = 0; i < size; i++) {
        x64_emit_byte(buf, 0x00);
    }

    return SERAPH_VBIT_TRUE;
}

Seraph_Vbit x64_labels_resolve(X64_Labels* labels, X64_Buffer* buf) {
    if (labels == NULL || buf == NULL) {
        return SERAPH_VBIT_FALSE;
    }

    for (size_t i = 0; i < labels->fixup_count; i++) {
        X64_Fixup* fixup = &labels->fixups[i];

        /* Find the target label */
        size_t target_offset = SIZE_MAX;
        for (size_t j = 0; j < labels->count; j++) {
            if (labels->labels[j].id == fixup->label_id) {
                target_offset = labels->labels[j].offset;
                break;
            }
        }

        if (target_offset == SIZE_MAX) {
            /* Undefined label */
            return SERAPH_VBIT_FALSE;
        }

        /* Calculate relative offset */
        /* The displacement is relative to the instruction AFTER the fixup */
        int64_t displacement = (int64_t)target_offset -
                               (int64_t)(fixup->patch_offset + fixup->size);

        /* Patch the displacement */
        switch (fixup->size) {
            case 1:
                if (displacement < -128 || displacement > 127) {
                    return SERAPH_VBIT_FALSE;  /* Overflow */
                }
                buf->code[fixup->patch_offset] = (uint8_t)(int8_t)displacement;
                break;

            case 2:
                if (displacement < -32768 || displacement > 32767) {
                    return SERAPH_VBIT_FALSE;
                }
                buf->code[fixup->patch_offset] = (uint8_t)(displacement & 0xFF);
                buf->code[fixup->patch_offset + 1] = (uint8_t)((displacement >> 8) & 0xFF);
                break;

            case 4:
                if (displacement < INT32_MIN || displacement > INT32_MAX) {
                    return SERAPH_VBIT_FALSE;
                }
                buf->code[fixup->patch_offset] = (uint8_t)(displacement & 0xFF);
                buf->code[fixup->patch_offset + 1] = (uint8_t)((displacement >> 8) & 0xFF);
                buf->code[fixup->patch_offset + 2] = (uint8_t)((displacement >> 16) & 0xFF);
                buf->code[fixup->patch_offset + 3] = (uint8_t)((displacement >> 24) & 0xFF);
                break;

            default:
                return SERAPH_VBIT_FALSE;
        }
    }

    return SERAPH_VBIT_TRUE;
}

/*============================================================================
 * MOV Instructions
 *============================================================================*/

void x64_mov_reg_imm64(X64_Buffer* buf, X64_Reg dst, uint64_t imm) {
    if (buf == NULL) return;

    /* MOV r64, imm64 (movabs) - REX.W + B8+rd + imm64 */
    uint8_t rex = x64_rex(1, 0, 0, dst >= X64_R8 ? 1 : 0);
    x64_emit_byte(buf, rex);
    x64_emit_byte(buf, 0xB8 + (dst & 7));
    x64_emit_qword(buf, imm);
}

void x64_mov_reg_imm32(X64_Buffer* buf, X64_Reg dst, int32_t imm) {
    if (buf == NULL) return;

    /* MOV r64, imm32 (sign-extended) - REX.W + C7 /0 + imm32 */
    uint8_t rex = x64_rex(1, 0, 0, dst >= X64_R8 ? 1 : 0);
    x64_emit_byte(buf, rex);
    x64_emit_byte(buf, 0xC7);
    x64_emit_byte(buf, x64_modrm(3, 0, dst & 7));
    x64_emit_dword(buf, (uint32_t)imm);
}

void x64_mov_reg_reg(X64_Buffer* buf, X64_Reg dst, X64_Reg src, X64_Size size) {
    if (buf == NULL) return;

    /* MOV r/m, r - 89 /r (with REX prefix for 64-bit) */
    if (size == X64_SZ_64 || dst >= X64_R8 || src >= X64_R8) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              src >= X64_R8 ? 1 : 0,
                              0,
                              dst >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0x89);
    x64_emit_byte(buf, x64_modrm(3, src & 7, dst & 7));
}

void x64_mov_reg_mem(X64_Buffer* buf, X64_Reg dst, X64_Reg base,
                     int32_t disp, X64_Size size) {
    if (buf == NULL) return;

    /* MOV r, r/m - 8B /r */
    int need_rex = (size == X64_SZ_64) || (dst >= X64_R8) || (base >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              dst >= X64_R8 ? 1 : 0,
                              0,
                              base >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0x8B);

    /* ModR/M encoding depends on base register and displacement */
    int base_low = base & 7;

    if (disp == 0 && base_low != 5) {  /* RBP/R13 always needs disp */
        /* [base] - mod 00 */
        if (base_low == 4) {  /* RSP/R12 needs SIB */
            x64_emit_byte(buf, x64_modrm(0, dst & 7, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));  /* index=RSP means no index */
        } else {
            x64_emit_byte(buf, x64_modrm(0, dst & 7, base_low));
        }
    } else if (disp >= -128 && disp <= 127) {
        /* [base + disp8] - mod 01 */
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(1, dst & 7, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(1, dst & 7, base_low));
        }
        x64_emit_byte(buf, (uint8_t)(int8_t)disp);
    } else {
        /* [base + disp32] - mod 10 */
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(2, dst & 7, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(2, dst & 7, base_low));
        }
        x64_emit_dword(buf, (uint32_t)disp);
    }
}

void x64_mov_mem_reg(X64_Buffer* buf, X64_Reg base, int32_t disp,
                     X64_Reg src, X64_Size size) {
    if (buf == NULL) return;

    /* MOV r/m, r - 89 /r */
    int need_rex = (size == X64_SZ_64) || (src >= X64_R8) || (base >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              src >= X64_R8 ? 1 : 0,
                              0,
                              base >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0x89);

    int base_low = base & 7;

    if (disp == 0 && base_low != 5) {
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(0, src & 7, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(0, src & 7, base_low));
        }
    } else if (disp >= -128 && disp <= 127) {
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(1, src & 7, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(1, src & 7, base_low));
        }
        x64_emit_byte(buf, (uint8_t)(int8_t)disp);
    } else {
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(2, src & 7, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(2, src & 7, base_low));
        }
        x64_emit_dword(buf, (uint32_t)disp);
    }
}

void x64_mov_mem_imm(X64_Buffer* buf, X64_Reg base, int32_t disp,
                     int32_t imm, X64_Size size) {
    if (buf == NULL) return;

    /* MOV r/m, imm - C7 /0 */
    int need_rex = (size == X64_SZ_64) || (base >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              0,
                              0,
                              base >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0xC7);

    int base_low = base & 7;

    if (disp == 0 && base_low != 5) {
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(0, 0, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(0, 0, base_low));
        }
    } else if (disp >= -128 && disp <= 127) {
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(1, 0, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(1, 0, base_low));
        }
        x64_emit_byte(buf, (uint8_t)(int8_t)disp);
    } else {
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(2, 0, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(2, 0, base_low));
        }
        x64_emit_dword(buf, (uint32_t)disp);
    }

    /* Emit immediate based on size */
    if (size == X64_SZ_8) {
        x64_emit_byte(buf, (uint8_t)(int8_t)imm);
    } else if (size == X64_SZ_16) {
        x64_emit_word(buf, (uint16_t)(int16_t)imm);
    } else {
        x64_emit_dword(buf, (uint32_t)imm);
    }
}

/*============================================================================
 * Arithmetic Instructions
 *============================================================================*/

/* Helper for reg-reg ALU operations with opcode */
static void x64_alu_reg_reg(X64_Buffer* buf, uint8_t opcode,
                            X64_Reg dst, X64_Reg src, X64_Size size) {
    if (buf == NULL) return;

    int need_rex = (size == X64_SZ_64) || (dst >= X64_R8) || (src >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              src >= X64_R8 ? 1 : 0,
                              0,
                              dst >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, opcode);
    x64_emit_byte(buf, x64_modrm(3, src & 7, dst & 7));
}

/* Helper for reg-imm ALU operations */
static void x64_alu_reg_imm(X64_Buffer* buf, uint8_t opcode_ext,
                            X64_Reg dst, int32_t imm, X64_Size size) {
    if (buf == NULL) return;

    int need_rex = (size == X64_SZ_64) || (dst >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              0,
                              0,
                              dst >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    if (imm >= -128 && imm <= 127 && size != X64_SZ_8) {
        /* Use short form with imm8 */
        x64_emit_byte(buf, 0x83);
        x64_emit_byte(buf, x64_modrm(3, opcode_ext, dst & 7));
        x64_emit_byte(buf, (uint8_t)(int8_t)imm);
    } else {
        /* Use full imm32 */
        x64_emit_byte(buf, 0x81);
        x64_emit_byte(buf, x64_modrm(3, opcode_ext, dst & 7));
        x64_emit_dword(buf, (uint32_t)imm);
    }
}

void x64_add_reg_reg(X64_Buffer* buf, X64_Reg dst, X64_Reg src, X64_Size size) {
    x64_alu_reg_reg(buf, 0x01, dst, src, size);  /* ADD r/m, r */
}

void x64_add_reg_imm(X64_Buffer* buf, X64_Reg dst, int32_t imm, X64_Size size) {
    x64_alu_reg_imm(buf, 0, dst, imm, size);  /* /0 for ADD */
}

void x64_sub_reg_reg(X64_Buffer* buf, X64_Reg dst, X64_Reg src, X64_Size size) {
    x64_alu_reg_reg(buf, 0x29, dst, src, size);  /* SUB r/m, r */
}

void x64_sub_reg_imm(X64_Buffer* buf, X64_Reg dst, int32_t imm, X64_Size size) {
    x64_alu_reg_imm(buf, 5, dst, imm, size);  /* /5 for SUB */
}

void x64_imul_reg_reg(X64_Buffer* buf, X64_Reg dst, X64_Reg src, X64_Size size) {
    if (buf == NULL) return;

    /* IMUL r, r/m - 0F AF /r */
    int need_rex = (size == X64_SZ_64) || (dst >= X64_R8) || (src >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              dst >= X64_R8 ? 1 : 0,
                              0,
                              src >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0x0F);
    x64_emit_byte(buf, 0xAF);
    x64_emit_byte(buf, x64_modrm(3, dst & 7, src & 7));
}

void x64_imul_reg_imm(X64_Buffer* buf, X64_Reg dst, X64_Reg src,
                       int32_t imm, X64_Size size) {
    if (buf == NULL) return;

    /* IMUL r, r/m, imm - 69 /r or 6B /r */
    int need_rex = (size == X64_SZ_64) || (dst >= X64_R8) || (src >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              dst >= X64_R8 ? 1 : 0,
                              0,
                              src >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    if (imm >= -128 && imm <= 127) {
        x64_emit_byte(buf, 0x6B);
        x64_emit_byte(buf, x64_modrm(3, dst & 7, src & 7));
        x64_emit_byte(buf, (uint8_t)(int8_t)imm);
    } else {
        x64_emit_byte(buf, 0x69);
        x64_emit_byte(buf, x64_modrm(3, dst & 7, src & 7));
        x64_emit_dword(buf, (uint32_t)imm);
    }
}

void x64_idiv_reg(X64_Buffer* buf, X64_Reg divisor, X64_Size size) {
    if (buf == NULL) return;

    /* IDIV r/m - F7 /7 */
    int need_rex = (size == X64_SZ_64) || (divisor >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              0,
                              0,
                              divisor >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0xF7);
    x64_emit_byte(buf, x64_modrm(3, 7, divisor & 7));
}

void x64_cqo(X64_Buffer* buf) {
    if (buf == NULL) return;
    /* CQO - REX.W + 99 */
    x64_emit_byte(buf, x64_rex(1, 0, 0, 0));
    x64_emit_byte(buf, 0x99);
}

void x64_cdq(X64_Buffer* buf) {
    if (buf == NULL) return;
    /* CDQ - 99 */
    x64_emit_byte(buf, 0x99);
}

void x64_neg_reg(X64_Buffer* buf, X64_Reg reg, X64_Size size) {
    if (buf == NULL) return;

    /* NEG r/m - F7 /3 */
    int need_rex = (size == X64_SZ_64) || (reg >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              0,
                              0,
                              reg >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0xF7);
    x64_emit_byte(buf, x64_modrm(3, 3, reg & 7));
}

/*============================================================================
 * Bitwise Instructions
 *============================================================================*/

void x64_and_reg_reg(X64_Buffer* buf, X64_Reg dst, X64_Reg src, X64_Size size) {
    x64_alu_reg_reg(buf, 0x21, dst, src, size);  /* AND r/m, r */
}

void x64_and_reg_imm(X64_Buffer* buf, X64_Reg dst, int32_t imm, X64_Size size) {
    x64_alu_reg_imm(buf, 4, dst, imm, size);  /* /4 for AND */
}

void x64_or_reg_reg(X64_Buffer* buf, X64_Reg dst, X64_Reg src, X64_Size size) {
    x64_alu_reg_reg(buf, 0x09, dst, src, size);  /* OR r/m, r */
}

void x64_xor_reg_reg(X64_Buffer* buf, X64_Reg dst, X64_Reg src, X64_Size size) {
    x64_alu_reg_reg(buf, 0x31, dst, src, size);  /* XOR r/m, r */
}

void x64_not_reg(X64_Buffer* buf, X64_Reg reg, X64_Size size) {
    if (buf == NULL) return;

    /* NOT r/m - F7 /2 */
    int need_rex = (size == X64_SZ_64) || (reg >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              0,
                              0,
                              reg >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0xF7);
    x64_emit_byte(buf, x64_modrm(3, 2, reg & 7));
}

/* Shift helper */
static void x64_shift_reg(X64_Buffer* buf, uint8_t opcode_ext,
                          X64_Reg reg, X64_Size size, int by_cl) {
    if (buf == NULL) return;

    int need_rex = (size == X64_SZ_64) || (reg >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              0,
                              0,
                              reg >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, by_cl ? 0xD3 : 0xD1);  /* D3 = shift by CL, D1 = shift by 1 */
    x64_emit_byte(buf, x64_modrm(3, opcode_ext, reg & 7));
}

static void x64_shift_reg_imm(X64_Buffer* buf, uint8_t opcode_ext,
                              X64_Reg reg, uint8_t imm, X64_Size size) {
    if (buf == NULL) return;

    int need_rex = (size == X64_SZ_64) || (reg >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              0,
                              0,
                              reg >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    if (imm == 1) {
        x64_emit_byte(buf, 0xD1);
        x64_emit_byte(buf, x64_modrm(3, opcode_ext, reg & 7));
    } else {
        x64_emit_byte(buf, 0xC1);
        x64_emit_byte(buf, x64_modrm(3, opcode_ext, reg & 7));
        x64_emit_byte(buf, imm);
    }
}

void x64_shl_reg_cl(X64_Buffer* buf, X64_Reg reg, X64_Size size) {
    x64_shift_reg(buf, 4, reg, size, 1);  /* /4 for SHL */
}

void x64_shl_reg_imm(X64_Buffer* buf, X64_Reg reg, uint8_t imm, X64_Size size) {
    x64_shift_reg_imm(buf, 4, reg, imm, size);
}

void x64_shr_reg_cl(X64_Buffer* buf, X64_Reg reg, X64_Size size) {
    x64_shift_reg(buf, 5, reg, size, 1);  /* /5 for SHR */
}

void x64_shr_reg_imm(X64_Buffer* buf, X64_Reg reg, uint8_t imm, X64_Size size) {
    x64_shift_reg_imm(buf, 5, reg, imm, size);
}

void x64_sar_reg_cl(X64_Buffer* buf, X64_Reg reg, X64_Size size) {
    x64_shift_reg(buf, 7, reg, size, 1);  /* /7 for SAR */
}

void x64_sar_reg_imm(X64_Buffer* buf, X64_Reg reg, uint8_t imm, X64_Size size) {
    x64_shift_reg_imm(buf, 7, reg, imm, size);
}

/*============================================================================
 * Comparison and Test
 *============================================================================*/

void x64_cmp_reg_reg(X64_Buffer* buf, X64_Reg dst, X64_Reg src, X64_Size size) {
    x64_alu_reg_reg(buf, 0x39, dst, src, size);  /* CMP r/m, r */
}

void x64_cmp_reg_imm(X64_Buffer* buf, X64_Reg reg, int32_t imm, X64_Size size) {
    x64_alu_reg_imm(buf, 7, reg, imm, size);  /* /7 for CMP */
}

void x64_test_reg_reg(X64_Buffer* buf, X64_Reg dst, X64_Reg src, X64_Size size) {
    if (buf == NULL) return;

    /* TEST r/m, r - 85 /r */
    int need_rex = (size == X64_SZ_64) || (dst >= X64_R8) || (src >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              src >= X64_R8 ? 1 : 0,
                              0,
                              dst >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0x85);
    x64_emit_byte(buf, x64_modrm(3, src & 7, dst & 7));
}

void x64_setcc(X64_Buffer* buf, X64_Condition cc, X64_Reg reg) {
    if (buf == NULL) return;

    /* SETcc r/m8 - 0F 9x /0 */
    if (reg >= X64_R8) {
        x64_emit_byte(buf, x64_rex(0, 0, 0, 1));
    }

    x64_emit_byte(buf, 0x0F);
    x64_emit_byte(buf, 0x90 + cc);
    x64_emit_byte(buf, x64_modrm(3, 0, reg & 7));
}

void x64_cmovcc(X64_Buffer* buf, X64_Condition cc, X64_Reg dst,
                X64_Reg src, X64_Size size) {
    if (buf == NULL) return;

    /* CMOVcc r, r/m - 0F 4x /r */
    int need_rex = (size == X64_SZ_64) || (dst >= X64_R8) || (src >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(size == X64_SZ_64 ? 1 : 0,
                              dst >= X64_R8 ? 1 : 0,
                              0,
                              src >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0x0F);
    x64_emit_byte(buf, 0x40 + cc);
    x64_emit_byte(buf, x64_modrm(3, dst & 7, src & 7));
}

/*============================================================================
 * Control Flow
 *============================================================================*/

void x64_jmp_label(X64_Buffer* buf, X64_Labels* labels, uint32_t label_id) {
    if (buf == NULL || labels == NULL) return;

    /* JMP rel32 - E9 + rel32 */
    x64_emit_byte(buf, 0xE9);
    x64_label_fixup(labels, buf, label_id, 4);
}

void x64_jcc_label(X64_Buffer* buf, X64_Condition cc,
                   X64_Labels* labels, uint32_t label_id) {
    if (buf == NULL || labels == NULL) return;

    /* Jcc rel32 - 0F 8x + rel32 */
    x64_emit_byte(buf, 0x0F);
    x64_emit_byte(buf, 0x80 + cc);
    x64_label_fixup(labels, buf, label_id, 4);
}

void x64_jmp_reg(X64_Buffer* buf, X64_Reg reg) {
    if (buf == NULL) return;

    /* JMP r/m64 - FF /4 */
    if (reg >= X64_R8) {
        x64_emit_byte(buf, x64_rex(0, 0, 0, 1));
    }

    x64_emit_byte(buf, 0xFF);
    x64_emit_byte(buf, x64_modrm(3, 4, reg & 7));
}

void x64_call_label(X64_Buffer* buf, X64_Labels* labels, uint32_t label_id) {
    if (buf == NULL || labels == NULL) return;

    /* CALL rel32 - E8 + rel32 */
    x64_emit_byte(buf, 0xE8);
    x64_label_fixup(labels, buf, label_id, 4);
}

void x64_call_reg(X64_Buffer* buf, X64_Reg reg) {
    if (buf == NULL) return;

    /* CALL r/m64 - FF /2 */
    if (reg >= X64_R8) {
        x64_emit_byte(buf, x64_rex(0, 0, 0, 1));
    }

    x64_emit_byte(buf, 0xFF);
    x64_emit_byte(buf, x64_modrm(3, 2, reg & 7));
}

void x64_ret(X64_Buffer* buf) {
    if (buf == NULL) return;
    x64_emit_byte(buf, 0xC3);
}

void x64_ret_imm(X64_Buffer* buf, uint16_t pop_bytes) {
    if (buf == NULL) return;
    x64_emit_byte(buf, 0xC2);
    x64_emit_word(buf, pop_bytes);
}

/*============================================================================
 * Stack Operations
 *============================================================================*/

void x64_push_reg(X64_Buffer* buf, X64_Reg reg) {
    if (buf == NULL) return;

    /* PUSH r64 - 50+rd */
    if (reg >= X64_R8) {
        x64_emit_byte(buf, x64_rex(0, 0, 0, 1));
    }

    x64_emit_byte(buf, 0x50 + (reg & 7));
}

void x64_push_imm(X64_Buffer* buf, int32_t imm) {
    if (buf == NULL) return;

    if (imm >= -128 && imm <= 127) {
        /* PUSH imm8 - 6A + imm8 */
        x64_emit_byte(buf, 0x6A);
        x64_emit_byte(buf, (uint8_t)(int8_t)imm);
    } else {
        /* PUSH imm32 - 68 + imm32 */
        x64_emit_byte(buf, 0x68);
        x64_emit_dword(buf, (uint32_t)imm);
    }
}

void x64_pop_reg(X64_Buffer* buf, X64_Reg reg) {
    if (buf == NULL) return;

    /* POP r64 - 58+rd */
    if (reg >= X64_R8) {
        x64_emit_byte(buf, x64_rex(0, 0, 0, 1));
    }

    x64_emit_byte(buf, 0x58 + (reg & 7));
}

void x64_enter(X64_Buffer* buf, uint16_t frame_size, uint8_t nesting_level) {
    if (buf == NULL) return;
    /* ENTER imm16, imm8 - C8 + imm16 + imm8 */
    x64_emit_byte(buf, 0xC8);
    x64_emit_word(buf, frame_size);
    x64_emit_byte(buf, nesting_level);
}

void x64_leave(X64_Buffer* buf) {
    if (buf == NULL) return;
    x64_emit_byte(buf, 0xC9);
}

/*============================================================================
 * Misc Instructions
 *============================================================================*/

void x64_nop(X64_Buffer* buf) {
    if (buf == NULL) return;
    x64_emit_byte(buf, 0x90);
}

void x64_nop_n(X64_Buffer* buf, int count) {
    if (buf == NULL) return;

    while (count > 0) {
        if (count >= 9) {
            /* 66 0F 1F 84 00 00 00 00 00 */
            x64_emit_byte(buf, 0x66);
            x64_emit_byte(buf, 0x0F);
            x64_emit_byte(buf, 0x1F);
            x64_emit_byte(buf, 0x84);
            x64_emit_byte(buf, 0x00);
            x64_emit_dword(buf, 0);
            count -= 9;
        } else if (count >= 8) {
            /* 0F 1F 84 00 00 00 00 00 */
            x64_emit_byte(buf, 0x0F);
            x64_emit_byte(buf, 0x1F);
            x64_emit_byte(buf, 0x84);
            x64_emit_byte(buf, 0x00);
            x64_emit_dword(buf, 0);
            count -= 8;
        } else if (count >= 7) {
            /* 0F 1F 80 00 00 00 00 */
            x64_emit_byte(buf, 0x0F);
            x64_emit_byte(buf, 0x1F);
            x64_emit_byte(buf, 0x80);
            x64_emit_dword(buf, 0);
            count -= 7;
        } else if (count >= 6) {
            /* 66 0F 1F 44 00 00 */
            x64_emit_byte(buf, 0x66);
            x64_emit_byte(buf, 0x0F);
            x64_emit_byte(buf, 0x1F);
            x64_emit_byte(buf, 0x44);
            x64_emit_byte(buf, 0x00);
            x64_emit_byte(buf, 0x00);
            count -= 6;
        } else if (count >= 5) {
            /* 0F 1F 44 00 00 */
            x64_emit_byte(buf, 0x0F);
            x64_emit_byte(buf, 0x1F);
            x64_emit_byte(buf, 0x44);
            x64_emit_byte(buf, 0x00);
            x64_emit_byte(buf, 0x00);
            count -= 5;
        } else if (count >= 4) {
            /* 0F 1F 40 00 */
            x64_emit_byte(buf, 0x0F);
            x64_emit_byte(buf, 0x1F);
            x64_emit_byte(buf, 0x40);
            x64_emit_byte(buf, 0x00);
            count -= 4;
        } else if (count >= 3) {
            /* 0F 1F 00 */
            x64_emit_byte(buf, 0x0F);
            x64_emit_byte(buf, 0x1F);
            x64_emit_byte(buf, 0x00);
            count -= 3;
        } else if (count >= 2) {
            /* 66 90 */
            x64_emit_byte(buf, 0x66);
            x64_emit_byte(buf, 0x90);
            count -= 2;
        } else {
            /* 90 */
            x64_emit_byte(buf, 0x90);
            count -= 1;
        }
    }
}

void x64_lea(X64_Buffer* buf, X64_Reg dst, X64_Reg base, int32_t disp) {
    if (buf == NULL) return;

    /* LEA r, [base + disp] - 8D /r */
    uint8_t rex = x64_rex(1, dst >= X64_R8 ? 1 : 0, 0, base >= X64_R8 ? 1 : 0);
    x64_emit_byte(buf, rex);
    x64_emit_byte(buf, 0x8D);

    int base_low = base & 7;

    if (disp == 0 && base_low != 5) {
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(0, dst & 7, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(0, dst & 7, base_low));
        }
    } else if (disp >= -128 && disp <= 127) {
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(1, dst & 7, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(1, dst & 7, base_low));
        }
        x64_emit_byte(buf, (uint8_t)(int8_t)disp);
    } else {
        if (base_low == 4) {
            x64_emit_byte(buf, x64_modrm(2, dst & 7, 4));
            x64_emit_byte(buf, x64_sib(0, 4, base_low));
        } else {
            x64_emit_byte(buf, x64_modrm(2, dst & 7, base_low));
        }
        x64_emit_dword(buf, (uint32_t)disp);
    }
}

void x64_lea_sib(X64_Buffer* buf, X64_Reg dst, X64_Reg base,
                 X64_Reg index, int scale, int32_t disp) {
    if (buf == NULL) return;

    /* LEA r, [base + index*scale + disp] */
    uint8_t rex = x64_rex(1,
                          dst >= X64_R8 ? 1 : 0,
                          index >= X64_R8 ? 1 : 0,
                          base >= X64_R8 ? 1 : 0);
    x64_emit_byte(buf, rex);
    x64_emit_byte(buf, 0x8D);

    /* Convert scale to encoding */
    int scale_enc = 0;
    switch (scale) {
        case 1: scale_enc = 0; break;
        case 2: scale_enc = 1; break;
        case 4: scale_enc = 2; break;
        case 8: scale_enc = 3; break;
        default: scale_enc = 0; break;
    }

    int base_low = base & 7;

    if (disp == 0 && base_low != 5) {
        x64_emit_byte(buf, x64_modrm(0, dst & 7, 4));
        x64_emit_byte(buf, x64_sib(scale_enc, index & 7, base_low));
    } else if (disp >= -128 && disp <= 127) {
        x64_emit_byte(buf, x64_modrm(1, dst & 7, 4));
        x64_emit_byte(buf, x64_sib(scale_enc, index & 7, base_low));
        x64_emit_byte(buf, (uint8_t)(int8_t)disp);
    } else {
        x64_emit_byte(buf, x64_modrm(2, dst & 7, 4));
        x64_emit_byte(buf, x64_sib(scale_enc, index & 7, base_low));
        x64_emit_dword(buf, (uint32_t)disp);
    }
}

void x64_movzx(X64_Buffer* buf, X64_Reg dst, X64_Reg src,
               X64_Size dst_size, X64_Size src_size) {
    if (buf == NULL) return;

    /* MOVZX r, r/m8 - 0F B6 /r */
    /* MOVZX r, r/m16 - 0F B7 /r */
    int need_rex = (dst_size == X64_SZ_64) || (dst >= X64_R8) || (src >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(dst_size == X64_SZ_64 ? 1 : 0,
                              dst >= X64_R8 ? 1 : 0,
                              0,
                              src >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    x64_emit_byte(buf, 0x0F);
    x64_emit_byte(buf, src_size == X64_SZ_8 ? 0xB6 : 0xB7);
    x64_emit_byte(buf, x64_modrm(3, dst & 7, src & 7));
}

void x64_movsx(X64_Buffer* buf, X64_Reg dst, X64_Reg src,
               X64_Size dst_size, X64_Size src_size) {
    if (buf == NULL) return;

    int need_rex = (dst_size == X64_SZ_64) || (dst >= X64_R8) || (src >= X64_R8);
    if (need_rex) {
        uint8_t rex = x64_rex(dst_size == X64_SZ_64 ? 1 : 0,
                              dst >= X64_R8 ? 1 : 0,
                              0,
                              src >= X64_R8 ? 1 : 0);
        x64_emit_byte(buf, rex);
    }

    if (src_size == X64_SZ_32 && dst_size == X64_SZ_64) {
        /* MOVSXD r64, r/m32 - 63 /r */
        x64_emit_byte(buf, 0x63);
    } else {
        /* MOVSX r, r/m8 - 0F BE /r */
        /* MOVSX r, r/m16 - 0F BF /r */
        x64_emit_byte(buf, 0x0F);
        x64_emit_byte(buf, src_size == X64_SZ_8 ? 0xBE : 0xBF);
    }
    x64_emit_byte(buf, x64_modrm(3, dst & 7, src & 7));
}

void x64_int3(X64_Buffer* buf) {
    if (buf == NULL) return;
    x64_emit_byte(buf, 0xCC);
}

void x64_syscall(X64_Buffer* buf) {
    if (buf == NULL) return;
    x64_emit_byte(buf, 0x0F);
    x64_emit_byte(buf, 0x05);
}

void x64_hlt(X64_Buffer* buf) {
    if (buf == NULL) return;
    x64_emit_byte(buf, 0xF4);
}

void x64_cli(X64_Buffer* buf) {
    if (buf == NULL) return;
    x64_emit_byte(buf, 0xFA);
}

void x64_sti(X64_Buffer* buf) {
    if (buf == NULL) return;
    x64_emit_byte(buf, 0xFB);
}

void x64_ud2(X64_Buffer* buf) {
    if (buf == NULL) return;
    /* UD2 - generates #UD exception, used for SERAPH VOID panic */
    x64_emit_byte(buf, 0x0F);
    x64_emit_byte(buf, 0x0B);
}
